### 提取的要点

#### 1. **白盒测试**
   - **定义**：白盒测试是一种测试策略，检查程序的内部结构和逻辑，通过静态或动态分析获取测试数据。
   - **步骤**：
     1. **静态代码分析**：使用工具（如 Findbugs）找出潜在问题，如空对象、线程安全等。
     2. **Diff 评估影响范围**：分析调用链和影响的范围，确定测试边界。
     3. **单元测试**：从上到下串行测试，确保影响的点都经过测试。
     4. **梳理代码逻辑**：绘制流程图/时序图，为后续接口测试提供依据。
     5. **接口测试**：基于代码梳理的检查点进行接口测试，确保逻辑完整。
     6. **Debug**：通过远程调试，验证整个流程。
   - **常用工具**：Cobertura、EclEmma、Jacoco。

#### 2. **接口测试**
   - **策略**：
     1. 构造正常/异常参数组合，发送请求并验证响应。
     2. 通过代码梳理，绘制时序图，基于时序图构造测试场景，确保逻辑覆盖。
   - **示例**：微信扫码支付的接口测试
     1. **并发请求**：测试相同订单的并发处理。
     2. **回调处理**：测试微信 Server 多次回调的应对逻辑。
     3. **订单确认**：测试正确/错误密码处理。

#### 3. **接口自动化测试**
   - **目标分析**：
     1. **功能维度**：支付、代收、代付等核心功能。
     2. **业务维度**：核心业务流程。
     3. **流量维度**：百万级、千万级流量。
     4. **风险维度**：资金风险等关键领域。
     5. **黄金流程维度**：核心业务流程的优先级。
   - **自动化策略**：
     1. **单接口**：针对单个接口进行测试。
     2. **模块级**：测试模块内部逻辑，如预下单->提交订单->确认支付。
     3. **系统级**：整个业务流程测试，如订单->支付->网关->回调。
   - **自动化目标**：定义接口覆盖率、黄金流程覆盖率等。
   - **框架建设**：
     1. **环境与工具**：设置 MySQL、Redis、Dubbo、Http 等环境和工具。
     2. **测试用例模板**：包括清理数据库、初始化数据、构造请求、断言数据库和日志输出等。

#### 4. **分库分表的关注点**
   - **表的数量**：采用 2 的幂指数。
   - **字段选择**：一般基于索引字段，保证数据均衡分布。
   - **查询与性能**：插入和查询逻辑需一致，关注分库分表后的性能，避免性能下降。

### 总结
- **白盒测试** 重点在于通过代码结构的分析确保逻辑覆盖，结合代码覆盖率工具，最大限度减少潜在 Bug。
- **接口测试** 需结合接口文档和代码逻辑，构建更全面的测试场景。
- **接口自动化测试** 应优先覆盖核心业务与关键风险点，通过自动化框架提升测试效率。


做接口测试必备的网络基础知识


面试时，无论是面试功能测试、自动化测试、测试开发甚至性能测试，都会问你计算机网络的基础知识。今天主要介绍一些高频的基于网络的面试题。
Cookie和Session的区别？‍‍
Cookie是访问一些网站后存储在本地的一些网站的信息，下次访问时应该减少一些步骤。另一个更准确的说法是，Cookie是服务器存储在本地机器上的一小段文本，随着每个请求发送到同一个服务器，这是一种在客户端保持状态的方案。因为HTTP协议是无状态的，当服务器需要记录用户的状态时，就需要一些机制来识别具体的用户，这个机制就是Session。

￼

Cookie和Session是解决http协议的无状态性，区别如下：
1.存储位置不同
Cookie是将用户数据通过加密的方式保存在客户端，大多数情况Cookie存储在浏览器；Session是用于控制客户端和服务端的连接，Session存储在服务器；
2.存储容量不同
单个Cookie保存的数据不得超过4kb，一个站点最多20个Cookie，Session一般情况下没有上限，不过建议不要存放太多东西，否则影响性能；
3.存取方式不同
Cookie只能用ASCII字符串，通过编码方式获取Unicode字符或者二进制数据，不好存储复杂的信息，而Session能存储任何类型的数据；
4.隐私策略/安全性不同
Cookie放在客户端，可以进行Cookie欺骗，所以不安全，Session放在服务端，更加安全；



5.有效期不同


Cookie可以设置属性达到长期有效，Session依赖于JSESSIONID的Cookie，Cookie JSESSIONID的过期时间默认为-1，只需要关闭窗口Session就会失效，就算不依赖Cookie，用UrL重写也不能完成，如果Session超时时间过长，容易导致内存溢出；



6.服务器压力不同
Cookie保存在本地，不存在服务端压力，Session保存在服务端，每个用户产生一个Session，当访问增多，会比较占用服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用Cookie；




7.浏览器支持不同


如果浏览器禁用Cookie，那么Cookie直接失效，Session比较好点，可以用URL重写；



8.cookie和session应用的场景

cookie：用户的登录状态，记录用户的习惯，如购物车；
session：登录验证；


￼





HTTP与HTTPS的区别？‍


HTTP协议传输的数据是未加密的，也就是明文，所以用HTTP协议传输隐私信息是非常不安全的。为了保证这些私有数据能够被加密传输，网景设计了SSL(SecureSocketsLayer)协议对HTTP协议传输的数据进行加密，由此诞生了HTTPS。简单来说，httpS协议是由SSL+HTTP协议构建的网络协议，可以用于加密传输和认证，比HTTP协议更安全。HTTP和HTTPS都是应用层协议，本质上没有区别。他们的区别是，HTTPS是安全版的HTTP，HTTP信息是明文传输的，HTTPS是安全的SSL加密传输，比HTTP协议更安全。它们使用不同的端口。默认情况下，HTTP使用端口80，而HTTPS使用端口443。


￼

HTTPS和HTTP的区别主要如下：总的来说：HTTPS=SSL+HTTP。
* https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
* http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
* http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443（这个只是默认端口不一样，实际上端口是可以改的）。
* http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



get请求与post请求的区别‍？‍




1.提交数据的形式

* GET方法一般是指获取服务器上的数据，请求参数（query string查询字符串）直接跟着URL后边，以?分割URL和传输数据，参数之间以&相连（？key1=value1&key2=value2）的形式，直接可以放到浏览器地址栏里，例如登录就是采用GET方法。如：login.actionname=ITester&password=idontknow&verify=%E4%BD%A0%E5 %A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4 %BD%A0%E5%A5%BD，其中%XX中的XX为该符号以16进制表示的ASCII。
* POST方法是指客户端给服务器上提交表单数据，会把数据放到请求数据字段中以&分隔各个字段，请求行不包含数据参数，地址栏也不会额外附带参数，所以POST是通过表单提交的，请求参数放在body中，如网页上的新用户的注册、调查问卷和答题就是采用POST方法。



2.提交数据的大小/长度


* get是直接在浏览器地址栏输入，直接影响到了URL的长度，但HTTP协议规范中其实是没有对URL限制长度的，限制URL长度的是客户端或服务器的支持的不同所影响：比如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、Firefox等，理论上没有长度限制，其限制取决于操作系统的支持。由于浏览器有限制，一般整个URL的长度可以很长，但是不能超过2049KB的大小限制，而post没有大小限制。

* post方式HTTP协议规范中也没有限定，起限制作用的是服务器的处理程序的处理能力。所以大小的限制还是得受各个web服务器配置的不同而影响。


3.提交数据的安全性


* 由于get的参数是在浏览器地址栏URL直接拼接，用户名和密码将明文出现在URL上，暴露在互联网中，安全性差，不能用来传递敏感信息。
* post请求参数放在body里，是通过表单数据提交，post比get方式的安全性要高。
get方式安全性弱因为以下几个原因：
1. 登录页面有可能被浏览器缓存；
2. 其他人查看浏览器的历史记录，那么别人就可以拿到你的账号和密码；
3. 当遇上跨站的攻击时，安全性的表现更差；


4.编码方式


* get的参数只能支持ASCII；
* post没有限制,也允许二进制数据；


5.请求方式


* get是获取指定的资源；
* post是向指定的资源提交要被处理的数据；



6.请求体


* get没有请求体；
* post有请求体；



7.效率方面


* get产生一个tcp数据包；
* post产生两个tcp数据包，post需要两步，时间上消耗要多一点，get比post更有效；



8.请求过程


* 对于get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据），get请求的过程：
1）浏览器请求tcp连接（第一次握手）；
2）服务器答应进行tcp连接（第二次握手）；
3）浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以 http会在此时进行第一次数据发送）；
4）服务器返回200OK响应；

* 而对于post，浏览器先发送header，服务器响应100continue，浏览器再发送data，服务器响应200ok（返回数据），post请求的过程：
1）浏览器请求tcp连接（第一次握手）；
2）服务器答应进行tcp连接（第二次握手）；
3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以 http 会 在此时进行第一次数据发送）；
4）服务器返回100 Continue响应；
5）浏览器发送数据；
6）服务器返回200 OK响应；



OSI七层模型的作用分别是？‍




1.应用层


OSI参考模型中最接近用户的层为计算机用户提供应用接口，也直接为用户提供各种网络服务。我们常用的应用层网络服务协议包括HTTP、HTTPS、FTP、POP3、SMTP等。



2.表示层


为应用层数据提供各种编码和转换功能，保证一个系统的应用层发送的数据能够被另一个系统的应用层识别。如果需要，该层可以提供一种标准表示，用于将计算机内部的各种数据格式转换为通信中使用的标准表示；



3.会话层


负责建立、管理和终止表示层实体之间的通信会话。这一层的通信由不同设备中应用程序之间的服务请求和响应组成；



4.传输层


主机之间建立了端到端的链路，传输层的作用是为上层协议提供端到端的可靠透明的数据传输服务，包括差错控制和流量控制。这一层将下层数据通信的细节与上层屏蔽开来，使得上层用户只能看到两个传输实体之间从主机到主机的可靠数据路径，可以由用户进行控制和设置。我们通常说的，TCP/ UDP就是在这一层。端口号既是这里的“端”；



5.网络层


通过IP寻址，建立两个节点之间的连接。对于传输层在源端发送的数据包，选择合适的路由和交换节点，并根据地址正确传输到目的端的传输层。


6.数据链路层


将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。在实际使用中，LLC子层并非必需；



7.物理层


实际信号的传输通过物理层实现，比特流通过物理介质传输。规定了液位、速度和电缆引脚。常用的设备包括(各种物理设备)集线器、中继器、调制解调器、网线、双绞线和同轴电缆，这些都是物理层的传输介质。


￼
编辑 搜图



请简述TCP三次握手和四次挥手？‍




1.三次握手


三次握手指的是创建连接的过程:首先，客户端向服务器发送请求，询问是否可以发送数据；服务器收到请求后，如果同意，会回复确认消息；收到确认消息后，客户端开始发送数据
第一次握手：建立连接时，客户端向服务器发送请求报文(SYN),"我想建立连接”；
第二次握手：服务器收到请求报文后，如同意连接，则向客户端发送确认报文（SYN/ACK），“同意建立”；
第三次握手：客户端收到服务器的确认后，再次向服务器发送确认报文，完成连接（ACK）；


￼
编辑 搜图



2.四次挥手

四次波指的是断开的过程:客户端向服务器发送请求，询问是否有可能断开；服务器将响应其当前状态；如果服务器准备好了，它将向客户端发送断开请求。如果还没有准备好，还有数据没有响应，它会等待响应完成后再向客户端发送请求；最后，服务器和客户端断开连接。
第一次挥手：客户端想分手，发送消息（FIN）给服务器；
第二次挥手：服务器通知客户端已经接受的挥手请求，返回确认消息（ACK），但还没做好分手准备；
第三次挥手：服务端已经做好分手准备，通知客户端（FIN）；
第四次挥手：客户端发送消息给服务器（ACK）,确认分手，服务器关闭连接。



￼
编辑 搜图



浏览器输入URL到将页面渲染出来发生了什么?‍


1.首先，在浏览器地址栏中输入URL，先解析URL，检测URL地址是否合法；

2.浏览器首先检查浏览器缓存-系统缓存-路由器缓存，如果缓存中有，页面内容会直接显示在屏幕上。如果没有，请跳到步骤3。
浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；
路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
ISP缓存：若上述均失败，继续向ISP搜索。

3.在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。

4.浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手。

5.握手成功后，浏览器向服务器发送HTTP请求，请求数据包。

6.服务器处理收到的请求，将数据返回至浏览器。

7.浏览器收到HTTP响应。

8.浏览器解码响应，如果响应可以缓存，则存入缓存。

9.浏览器发送请求获取嵌入在HTML中的资源（HTML，CSS，JavaScript，图片，音乐······），对于未知类型，会弹出对话框。

10.浏览器发送异步请求。

11. 最后，页面全部渲染结束。



￼
编辑 搜图



常用HTTP状态码‍


关于常见的HTTP状态码，这是一个面试经常问的题目。
状态码	类别
常见的HTTP状态码：


1.1XX


* 100 Continue：表示正常，客户端可以继续发送请求
* 101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。



2.2XX


* 200 OK：请求成功
* 201 Created：已创建，表示成功请求并创建了新的资源
* 202 Accepted：已接受，已接受请求，但未处理完成。
* 204 No Content：无内容，服务器成功处理，但未返回内容。
* 205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。
* 206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容


3.3XX


* 301 Moved Permanently：永久性重定向
* 302 Found：临时重定向
* 303 See Other：和301功能类似，但要求客户端采用get方法获取资源
* 304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
* 305 Use Proxy：所请求的资源必须通过代理访问
* 307 Temporary Redirect：临时重定向，与302类似，要求使用get请求重定向。



4.4XX


* 400 Bad Request：客户端请求的语法错误，服务器无法理解。
* 401 Unauthorized：表示发送的请求需要有认证信息。
* 403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求
* 404 Not Found：服务器无法根据客户端的请求找到资源。
* 405 Method Not Allowed：客户端请求中的方法被禁止
* 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求。
* 408 Request Time-out：服务器等待客户端发送的请求时间过长，超时。



5.5XX


* 500 Internal Server Error：服务器内部错误，无法完成请求
* 501 Not Implemented：服务器不支持请求的功能，无法完成请求



如果已经建立了连接，但是客户端突然出现故障了怎么办？‍


如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。
保活机制原理：设置TCP保活机制的保活时间keepIdle，即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。




TCP 和 UDP 区别及应用场景？‍



1.TCP和UDP区别


面向连接 vs 无连接
可靠性：TCP 可靠，丢包重传；UDP 不可靠。
有序性：TCP 利用序列号保证了数据的有序性（数据到达会排序）
速度：TCP 创建连接，速率较慢；UDP 较快
TCP 流模式，UDP 报文模式



2.TCP和UDP应用场景


TCP：
当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。在日常生活中，常见使用 TCP 协议的应用如下：
* 万维网（HTTP）；
* 邮件（POP、SMTP）；
* 文件传输（FTP）；

UDP：
当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。日常生活中常见使用 UDP 协议的应用如：语音，视频。